import { describe, it, expect } from '@jest/globals'
import { execSync } from 'child_process'
import * as fs from 'fs'
import * as path from 'path'

describe('Vulnerability Scanning Tests', () => {
  describe('Dependency Security', () => {
    it('should not have known vulnerabilities in dependencies', async () => {
      try {
        // Run npm audit and capture output
        const auditResult = execSync('npm audit --json', { 
          encoding: 'utf8',
          cwd: process.cwd()
        })
        
        const audit = JSON.parse(auditResult)
        
        // Check for high/critical vulnerabilities
        const criticalVulns = audit.vulnerabilities ? 
          Object.values(audit.vulnerabilities).filter((vuln: any) => 
            vuln.severity === 'critical' || vuln.severity === 'high'
          ) : []
        
        expect(criticalVulns.length).toBe(0)
        
        if (criticalVulns.length > 0) {
          console.warn(`ðŸš¨ Found ${criticalVulns.length} critical/high vulnerabilities:`)
          criticalVulns.forEach((vuln: any) => {
            console.warn(`- ${vuln.name}: ${vuln.severity}`)
          })
        }
      } catch (error) {
        // npm audit exits with non-zero code when vulnerabilities found
        if (error instanceof Error && 'stdout' in error) {
          const auditOutput = (error as any).stdout
          try {
            const audit = JSON.parse(auditOutput)
            const highSeverity = audit.metadata?.vulnerabilities?.high || 0
            const critical = audit.metadata?.vulnerabilities?.critical || 0
            
            expect(critical + highSeverity).toBe(0)
          } catch (parseError) {
            // If we can't parse the output, log it for manual review
            console.warn('npm audit output could not be parsed:', auditOutput)
          }
        }
      }
    })

    it('should have security-focused package.json configuration', () => {
      const packageJsonPath = path.join(process.cwd(), 'package.json')
      expect(fs.existsSync(packageJsonPath)).toBe(true)
      
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'))
      
      // Check for security testing scripts
      expect(packageJson.scripts).toHaveProperty('test:security')
      expect(packageJson.scripts).toHaveProperty('security:scan')
      
      // Check for security-related dev dependencies
      const securityDeps = [
        'jest',
        'supertest',
        'eslint-plugin-security',
        'audit-ci'
      ]
      
      securityDeps.forEach(dep => {
        expect(packageJson.devDependencies).toHaveProperty(dep)
      })
    })
  })

  describe('Code Security Analysis', () => {
    it('should not contain hardcoded secrets', () => {
      const secretPatterns = [
        /sk_test_[a-zA-Z0-9]+/g, // Stripe test keys
        /sk_live_[a-zA-Z0-9]+/g, // Stripe live keys
        /pk_test_[a-zA-Z0-9]+/g, // Stripe public test keys
        /pk_live_[a-zA-Z0-9]+/g, // Stripe public live keys
        /AIza[0-9A-Za-z\\-_]{35}/g, // Google API keys
        /ya29\\.[0-9A-Za-z\\-_]+/g, // Google OAuth tokens
        /[a-zA-Z0-9-_]{24}\\.[a-zA-Z0-9-_]{6}\\.[a-zA-Z0-9-_]{27}/g, // JWT tokens
        /(eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*)/g, // JWT pattern
        /password\\s*=\\s*['""][^'""]+['""]|pwd\\s*=\\s*['""][^'""]+['""]]/gi, // Hardcoded passwords
        /secret\\s*=\\s*['""][^'""]+['""]|key\\s*=\\s*['""][^'""]+['""]]/gi // Hardcoded secrets
      ]

      const searchDirs = ['src', 'pages', 'components']
      const violations: string[] = []

      const scanDirectory = (dir: string) => {
        if (!fs.existsSync(dir)) return

        const files = fs.readdirSync(dir, { withFileTypes: true })
        
        for (const file of files) {
          const filePath = path.join(dir, file.name)
          
          if (file.isDirectory() && !file.name.startsWith('.') && file.name !== 'node_modules') {
            scanDirectory(filePath)
          } else if (file.isFile() && (file.name.endsWith('.ts') || file.name.endsWith('.tsx') || file.name.endsWith('.js') || file.name.endsWith('.jsx'))) {
            const content = fs.readFileSync(filePath, 'utf8')
            
            secretPatterns.forEach((pattern, index) => {
              const matches = content.match(pattern)
              if (matches) {
                violations.push(`${filePath}: Potential secret pattern ${index + 1}: ${matches[0].substring(0, 20)}...`)
              }
            })
          }
        }
      }

      searchDirs.forEach(scanDirectory)

      if (violations.length > 0) {
        console.warn('ðŸš¨ Potential hardcoded secrets found:')
        violations.forEach(violation => console.warn(violation))
      }

      expect(violations.length).toBe(0)
    })

    it('should not contain dangerous function calls', () => {
      const dangerousFunctions = [
        'eval(',
        'Function(',
        'setTimeout(', // When used with strings
        'setInterval(', // When used with strings
        'document.write(',
        'innerHTML =',
        'outerHTML =',
        'dangerouslySetInnerHTML',
        'exec(',
        'execSync(',
        'spawn('
      ]

      const searchDirs = ['src']
      const violations: string[] = []

      const scanDirectory = (dir: string) => {
        if (!fs.existsSync(dir)) return

        const files = fs.readdirSync(dir, { withFileTypes: true })
        
        for (const file of files) {
          const filePath = path.join(dir, file.name)
          
          if (file.isDirectory() && !file.name.startsWith('.') && file.name !== '__tests__') {
            scanDirectory(filePath)
          } else if (file.isFile() && (file.name.endsWith('.ts') || file.name.endsWith('.tsx'))) {
            const content = fs.readFileSync(filePath, 'utf8')
            
            dangerousFunctions.forEach(func => {
              if (content.includes(func)) {
                violations.push(`${filePath}: Contains potentially dangerous function: ${func}`)
              }
            })
          }
        }
      }

      searchDirs.forEach(scanDirectory)

      // Filter out legitimate uses (like in security tests)
      const legitimateViolations = violations.filter(violation => 
        !violation.includes('__tests__') && 
        !violation.includes('security') &&
        !violation.includes('test')
      )

      if (legitimateViolations.length > 0) {
        console.warn('ðŸš¨ Potentially dangerous functions found:')
        legitimateViolations.forEach(violation => console.warn(violation))
      }

      expect(legitimateViolations.length).toBe(0)
    })
  })

  describe('Configuration Security', () => {
    it('should have secure environment configuration', () => {
      const envExamplePath = path.join(process.cwd(), '.env.example')
      
      if (fs.existsSync(envExamplePath)) {
        const envExample = fs.readFileSync(envExamplePath, 'utf8')
        
        // Should not contain actual secrets in .env.example
        const suspiciousPatterns = [
          /sk_live_/,
          /pk_live_/,
          /password=.+/,
          /secret=.+[^<>]/,
          /key=.+[^<>]/
        ]

        suspiciousPatterns.forEach(pattern => {
          expect(pattern.test(envExample)).toBe(false)
        })

        // Should contain placeholder values
        expect(envExample).toMatch(/your-|<|>|example|placeholder/i)
      }
    })

    it('should have proper Next.js security configuration', () => {
      const nextConfigPath = path.join(process.cwd(), 'next.config.ts')
      
      if (fs.existsSync(nextConfigPath)) {
        const nextConfig = fs.readFileSync(nextConfigPath, 'utf8')
        
        // Check for security headers configuration
        // This is a basic check - in production, verify actual headers
        const hasSecurityMentions = nextConfig.includes('headers') || 
                                   nextConfig.includes('security') ||
                                   nextConfig.includes('Content-Security-Policy')

        // For now, just verify the file exists and is readable
        expect(nextConfig.length).toBeGreaterThan(0)
      }
    })

    it('should not expose sensitive files', () => {
      const sensitiveFiles = [
        '.env',
        '.env.local',
        '.env.production',
        'private.key',
        'id_rsa',
        'config.json'
      ]

      // Check that sensitive files are in .gitignore
      const gitignorePath = path.join(process.cwd(), '.gitignore')
      if (fs.existsSync(gitignorePath)) {
        const gitignore = fs.readFileSync(gitignorePath, 'utf8')
        
        sensitiveFiles.forEach(file => {
          const isIgnored = gitignore.includes(file) || 
                           gitignore.includes('*.env') || 
                           gitignore.includes('.env*')
          
          if (file.startsWith('.env')) {
            expect(isIgnored).toBe(true)
          }
        })
      }
    })
  })

  describe('Third-party Security', () => {
    it('should use HTTPS for external dependencies', () => {
      const packageJsonPath = path.join(process.cwd(), 'package.json')
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'))
      
      const allDeps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      }

      Object.entries(allDeps).forEach(([name, version]) => {
        if (typeof version === 'string' && version.startsWith('http://')) {
          throw new Error(`Insecure HTTP dependency found: ${name}@${version}`)
        }
      })
    })
  })
})